---
title: " "
format:
  pdf:
    include-in-header:
      - text: |
          \usepackage{amssymb}
---

```{r}
#| include: false

library(data.table)
set.seed(7)
ftwo <- function(x) format(x, digits=2, nsmall=2)
ci <- function(a,b,l=0.025,u=0.975) qbeta(c(l, u), a, b)
betamean <- function(a,b) a / (a + b)
betavar <- function(a,b,n){
  m <- betamean(a,b)
  return((m * (1-m)) / (a + b + n + 1))
}

sp <- function(prior, data=NULL, posterior=NULL){
    priorc <- rgb(177, 18, 37, alpha=75, maxColorValue = 255)
    posteriorc <- rgb(81, 40, 136, alpha=150, maxColorValue = 255)
    likelihoodc <- rgb(6, 42, 199, alpha=75, maxColorValue = 255)
    
    x <- seq(0,1,length.out=1001)
    
    for(i in 1:ncol(prior)){
      priormean <- betamean(prior['alpha',i], prior['beta',i])
      if(!is.null(data)){
        y <- apply(data, 2, sum)[i]
        n <- rep(nrow(data), ncol(data))[i]
        theta <- rbeta(1000, prior['alpha',i], prior['beta',i])
        db <- dbinom(y, n, theta)
        likelihoodmean <- ftwo(mean(db))
        dlikelihood <- dbinom(y, n, x)
        dl <- choose(n, y) * (x^y) * ((1-x)^(n-y))
      }
      priormean <- ftwo(priormean)
      main <- ""
      if(!is.null(posterior)){
        posteriormean <- ftwo(betamean(posterior['alpha',i], posterior['beta',i]))
        dposterior <- dbeta(x, posterior['alpha',i], posterior['beta',i])
      }else{
        dposterior <- NULL
        dlikelihood <- NULL
      }
      
      dprior <- dbeta(x, prior['alpha',i], prior['beta',i])
      ym <- 1.5*max(c(dprior, dposterior, dlikelihood))
      dii <- paste0(di, ",", i)
      if(is.null(posterior)) main <- bquote(n[.(i)] * " = 20")
      plot(x, 
           type='n',main=main,font.main=1,
           ylab='', xlab='', yaxt='n', yaxs='i', xaxt='n',xaxs='i',
           ylim=c(0,ym), xlim=c(0,1))
      polygon(x=x, y=dprior, col=priorc)
      if(!is.null(data)) polygon(c(x, rev(x)), c(dlikelihood, rep(0, length(dlikelihood))), col=likelihoodc)
      if(!is.null(posterior)) polygon(x=x, y=dposterior, col=posteriorc)
      leg <- c(bquote("E(" * theta[.(i)] * ") = " * .(priormean)))
      f <- c(priorc)
      if(!is.null(data)){
        leg <- c(leg, bquote("E(" * y[.(dii)] *  "|" * theta[.(i)] * ") = " * .(likelihoodmean)))
        f <- c(f, likelihoodc)
      }
      if(!is.null(posterior)){
        f <- c(f, posteriorc)
        leg <- c(leg, bquote("E(" * theta[.(i)] * "|" * y[.(dii)] * ") = " * .(posteriormean)))
      }
      legend(x="topleft",
             legend = leg,
             fill = f,
             bty = "n",
             cex = 1,
             x.intersp = 0.2,
             pt.cex = 0.8,
             xjust = 0, yjust=1,
             inset=0)
     }
}

subpriors <- function(n=20, alphas=c(5,10,15,17,19)+1){
  betas <- (n + 2) - alphas
  prior <- matrix(data = c(alphas, betas),
                   nrow=2,
                   ncol=length(alphas),
                   byrow=TRUE)
  rownames(prior) <- c("alpha","beta")
  return(prior)
}

getposterior <- function(prior, data){
  y <- apply(data, 2, sum)
  n <- rep(nrow(data), ncol(data))
  alpha <- prior['alpha',] + y
  beta <- prior['beta',] + n - y
  posterior <- matrix(data = c(alpha, beta), nrow=2, ncol=ncol(prior), byrow=TRUE)
  rownames(posterior) <- c("alpha","beta")
  return(posterior)
}

overall <- function(prior, x = seq(0,1,length.out=1000), rsn=1000){
  thetas <- mapply(rbeta, n=rsn, shape1=prior['alpha',], shape2=prior['beta',])
  mthetas <- apply(thetas, 1, mean)
  return(mthetas)
}

oplot <- function(thetao, data=T){
   m <- ftwo(mean(thetao))
   cio <- quantile(thetao, probs = c(0.025, 0.50, 0.975))
   main <- "" 
   if(!data) main <- bquote("N = 100")
   oc <- rgb(86, 35, 127, alpha=200, maxColorValue = 255)
   dens <- density(thetao)
   plot(x=seq(0,1,length.out=100),main=main,font.main=1,
        type='n',ylab='', xlab='', yaxt='n', yaxs='i', xaxt='n',xaxs='i',
        xlim=c(0,1), ylim=c(0,max(dens$y) * 1.2))
   hist(thetao, 
        add = TRUE,
        breaks=seq(0,1,length.out=100),
        border = NA,
        col = oc, 
        freq = FALSE,
        ylab='', xlab='', yaxt='n', yaxs='i', xaxt='n',xaxs='i',
        xlim=c(0,1))
   lines(dens, col='black')
  oci <- sprintf("[%.2f, %.2f, %.2f]", cio[1], cio[2], cio[3])
  
  if (data){
    leg <- bquote("E(" * theta * "|" * y[.(di)]  * ") = " * .(m) * ".")
  }else{
    leg <- bquote("E(" * theta * ") = " * .(m) * ".")
  }
  legend("topleft", legend = c(leg),
                               #bquote("[0.25%, 50%, 97.5%]:"),
                               #bquote(.(oci) * ".")),
         fill = c(oc,NA,NA),border = c('black', NA, NA),
         bty = "n",
         cex = c(1,.8,.8),
         x.intersp = 0.2,
         pt.cex = 0.8,
         xjust = 0, yjust=1,inset=0)
  text(x=0, y=0.5, pos= c(4,3),
       labels = bquote(.(oci) * "."), cex = .8)
}
```

\newcommand{\h}{$\scriptstyle \heartsuit\ $}
\textbf{RSVPs} \textit{or how I learned how many people will attend your wedding}
\vspace{1em}
 
\h Let $\theta$ be the true proportion of people that will attend your wedding out of $N$ total invitations that you send.

\h Let $y$ be the yes's out of $n$ RSVPs you have received to date.

\h We want to know the posterior density of $\theta$ given the data $y$.
 
\h Given $\theta$, the likelihood of getting $y$ yes's and $n - y$ no's is $$p(y|\theta) \propto \theta^y(1-\theta)^{n - y}.$$

\h A conjugate prior for $\theta$ is $$p(\theta) \propto \theta^{\alpha-1}(1-\theta)^{\beta-1},\ \text{where}\ \theta \sim \text{Beta}(\alpha, \beta).$$

\h Using Bayes' rule, the posterior density for $\theta$ is

$$
\begin{array}{lcl}
p(\theta|y) & \propto & p(y|\theta)p(\theta) \\
& = & \theta^{y+\alpha-1}(1-\theta)^{n-y+\beta-1} \\
& = & \text{Beta}(\alpha+y, \beta+n-y).
\end{array}
$$

\h The posterior mean of $\theta$ is an average of the prior mean ($\frac{\alpha}{\alpha + \beta}$) and the sample mean ($\frac{y}{n}$): $$\text{E}(\theta|y) = \frac{\alpha + y}{\alpha + \beta + n}.$$

\h The posterior variance of $\theta$ is 
$$
\text{var}(\theta|y) = \frac{(\alpha + y)(\beta + n - y)}{(\alpha + \beta +b)^2(\alpha + \beta + n +1)} = 
\frac{\text{E}(\theta|y)[1 - \text{E}(\theta|y)]}{\alpha + \beta + n + 1}.
$$

\h The prior density is equivalent to having received $\alpha - 1$ previous yes's and $\beta - 1$ previous no's. As $y$ and $n-y$ grow large compared to $\alpha$ and $\beta$, the posterior mean approaches the sample mean and the posterior variance goes to 0 at rate $\frac{1}{n}$.

\h After each response we can update the prior with the previous posterior.

```{r}
#| echo: false
#| results: asis


priorsi <- subpriors()
theta <- mapply(betamean, a = priorsi['alpha',]+1, b = priorsi['beta',]-1)
data <- mapply(rbinom, n=20, size=1, prob=theta)
prior <- priorsi

dp <- t(sapply(seq(1,17,4), function(i){
  d <- data[i:(i+3),]
  apply(d, 2, sum)
}))
```

\newpage
\h Suppose there be 5 subgroups such that the prior distribution is a joint distribution of 5 distinct priors: $$p(\theta) = p(\theta_1,\theta_2,\theta_3,\theta_4, \theta_5).$$ 

\h Where the $\theta$s come from the Beta distributions:

```{r}
#| echo: false
#| results: asis

b <- function(){
cat("$$\\begin{array}{r|ccccc}")
cat("p(\\theta) = p(\\theta_1,\\theta_2,\\theta_3,\\theta_4,\\theta_5) & ",paste0(paste0("\\theta_",1:5), collapse=" & "),"\\\\ \\hline")
cat(paste0(c("\\alpha & ","\\beta & "),apply(priorsi, 1, function(row) paste0(row, collapse=" & ")), collapse = "\\\\ "))
cat("\\end{array}$$")
}
b()
```


\h Each subgroup represents expected responses from $n = \alpha + \beta - 2 = 20$ people.

\h The joint distributions can be computed by taking 1000 samples from each of the subgroup prior distributions.

\h How will the posterior distributions update if you receive the following data? Each column represents responses associated with a given subgroup. Each row is the number of yes's out of 4 invitations received over time.
\newpage
```{r}
#| echo: false
#| results: asis

b()
```


```{r}
#| echo: false
#| fig-width: 8
#| fig-height: 8

par(mar = rep(0.25,4))
par(mar = c(.25,.25,2,.25))
par(mfrow = c(6,6))
di <<- 0
sp(prior)
oplot(overall(prior), data=F)
par(mar = rep(0.25,4))
di <<- di + 1
for (i in seq(1,17,4)){
  d <- data[i:(i+3),]
  posterior <- getposterior(prior, d)
  sp(prior, d, posterior)
  prior <- posterior
  thetao <- overall(prior)
  oplot(thetao)
  di <<- di + 1
}
```

```{r}
#| echo: false
#| results: asis
cat("$$\\tiny y = \\left[\\begin{array}{ccccc}")
cat(paste0(apply(dp, 1, function(row) paste0(row, collapse=" & ")), collapse = "\\\\"))
cat("\\end{array}\\right]$$")
```

